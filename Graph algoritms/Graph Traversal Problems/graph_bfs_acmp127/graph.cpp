//127. ¬ неориентированном графе требуетс€ найти длину кратчайшего пути между двум€ вершинами.
//¬о входном файле INPUT.TXT записано сначала число N - количество вершин в графе(1 <= N <= 100).
//«атем записана матрица смежности(0 обозначает отсутствие ребра, 1 - наличие ребра).
//«атем записаны номера двух вершин - начальной и конечной.
//¬ выходной файл OUTPUT.TXT выведите длину кратчайшего пути.
//≈сли пути не существует, выведите одно число - 1.

#include <fstream>
#include <queue>
using std::ifstream;
using std::ofstream;
using std::queue;

const int len = 101;
int g[len][len]; // cоздаем массив глобально, тогда он сразу инициализирован нул€ми, и мы не тратим на это врем€. » не придетс€ посо€нно переаллоцировать его, так как N <= 100
int m[len]; // cоздаем массив marked - кого мы уже добавили в очередь

int bfs_route(int a, int b, int n, int g[len][len], int m[len]) //на вход: точка старта bfs, точка конца, количество элементов, матрицасмежности, массив marked (помеченных)
{
	queue <int> q;
	q.push(a);
	m[a] = 1; //пишем 1, а не 0, потому что наш массив сразу заполнен нул€ми, и не хочетс€ перезаполн€ть его (-1). ѕоэтому в конце их пути просто вычтем 1.
	while (!q.empty()){
		int v = q.front();
		q.pop();
		for (int i = 1; i <= n; ++i){ //пробегаем по сосед€м
			if (g[v][i]){ //пробегаем по сосед€м в матрице смежности
				if (!m[i]){
					m[i]=m[v]+1;
					q.push(i);
				}
			}
		}
	}
	if (a == b)
		return 0;
	else
		if (m[b] == 1)
			return -1;
		else
			return m[b] - 1;	
}

int main()
{
	ifstream fin;
	ofstream fout;
	fin.open("input.txt");
	fout.open("output.txt");

	int n; //количество элементов
	int a; //точка начала пути
	int b; //точка конца пути
	fin >> n;
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= n; ++j)
			fin >> g[i][j];
	fin >> a >> b;
	int res = bfs_route(a, b, n, g, m);
	fout << res;
	fin.close();
	fout.close();
	return 0;
}